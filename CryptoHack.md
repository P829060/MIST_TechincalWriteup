# CryptoHack Challs

## PRIMES PART 1

### 1) Factoring
Factorise the 150-bit number 510143758735509025530880200653196460532653147 into its two constituent primes. Give the smaller one as your answer.
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving 
I had to use a website tool [Click here for the website](https://factordb.com/index.php?query=). This generated 2 prime factors of the given number. From this, I selected the smallest among them and that was the required flag.

Alternate Solution:
You can even use a python code (which i found online and seems easier to implement).
Refer the image below:
![Python Code](https://github.com/P829060/MIST_TechincalWriteup/blob/5acefd2ecba7b992f2df71170f4e637553bf0690/images/FactoringPrimesPythonCode.png)

### Flag
> 19704762736204164635843

### 2) Inferius Prime
Here is my super-strong RSA implementation, because it's 1600 bits strong it should be unbreakable... at least I think so!
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving
This required basic RSA formulae implementation like:

-   a ^ b % c | pow(a,b,c) in python
-   cipher = msg ^e % N
-   N = p * q
-   d = e ^(-1) mod [(p-1) * (q-1)]
-   msg = cipher ^ d % N 
  
![Inferius Prime](https://github.com/P829060/MIST_TechincalWriteup/blob/abcdbcfaf0cfab819f4c5819b0e0d29853f86f11/images/inferius%20whatever%20primes.png)

Python Code As Follows:
```python
from Crypto.Util.number import long_to_bytes
n = 984994081290620368062168960884976209711107645166770780785733
e = 65537
ct = 948553474947320504624302879933619818331484350431616834086273
p = 848445505077945374527983649411 
q = 1160939713152385063689030212503
d = pow(e,-1,(p-1)*(q-1))
pt = pow(ct,d,n)
print(long_to_bytes(pt))
```

### Flag
> crypto{N33d_b1g_pR1m35}

### 3) Monoprime
Why is everyone so obsessed with multiplying two primes for RSA. Why not just use one?
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving
Again, same as above formulae implementation:
This required basic RSA formulae implementation like:

-   a ^ b % c | pow(a,b,c) in python
-   cipher = msg ^e % N
-   N = p * q
-   d = e ^(-1) mod [(p-1) * (q-1)]
-   msg = cipher ^ d % N

Python Code As Follows:
```python
from Crypto.Util.number import long_to_bytes

n =171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591                                                                  
e = 65537
ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

d = pow(e,-1,n-1)

msg = pow(ct,d,n)

print(long_to_bytes(msg))

# Output: b'crypto{0n3_pr1m3_41n7_pr1m3_l0l}'
```
### Flag
> crypto{0n3_pr1m3_41n7_pr1m3_l0l}

### 4) Square Eyes
It was taking forever to get a 2048 bit prime, so I just generated one and used it twice.
"If you're stuck, look again at the formula for Euler's totient."
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving
This again requires the basic formulae but the important thing to note here is that n is a square of 2 primes that are equal. Therefore n = p*q ,where p=q.
So, in this case Euler's Totient Fucntion will be equal to q**(p-1) or p**(p-1).

Basic RSA Formulae:
-   a ^ b % c | pow(a,b,c) in python
-   cipher = msg ^e % N
-   N = p * q , where p = q
-   d = e ^(-1) mod [p(p-1)]
-   msg = cipher ^ d % N

Python Code As Follows:
```python
 from Crypto.Util.number import long_to_bytes

p=23148667521998097720857168827790771337662483716348435477360567409355026169165934446949809664595523770853897203103759106983985113264049057416908191166720008503275951625738975666019029172377653170602440373579593292576530667773951407647222757756437867216095193174201323278896027294517792607881861855264600525772460745259440301156930943255240915685718552334192230264780355799179037816026330705422484000086542362084006958158550346395941862383925942033730030004606360308379776255436206440529441711859246811586652746028418496020145441513037535475380962562108920699929022900677901988508936509354385660735694568216631382653107

n = 535860808044009550029177135708168016201451343147313565371014459027743491739422885443084705720731409713775527993719682583669164873806842043288439828071789970694759080842162253955259590552283047728782812946845160334801782088068154453021936721710269050985805054692096738777321796153384024897615594493453068138341203673749514094546000253631902991617197847584519694152122765406982133526594928685232381934742152195861380221224370858128736975959176861651044370378539093990198336298572944512738570839396588590096813217791191895941380464803377602779240663133834952329316862399581950590588006371221334128215409197603236942597674756728212232134056562716399155080108881105952768189193728827484667349378091100068224404684701674782399200373192433062767622841264055426035349769018117299620554803902490432339600566432246795818167460916180647394169157647245603555692735630862148715428791242764799469896924753470539857080767170052783918273180304835318388177089674231640910337743789750979216202573226794240332797892868276309400253925932223895530714169648116569013581643192341931800785254715083294526325980247219218364118877864892068185905587410977152737936310734712276956663192182487672474651103240004173381041237906849437490609652395748868434296753449
e = 65537
ct = 222502885974182429500948389840563415291534726891354573907329512556439632810921927905220486727807436668035929302442754225952786602492250448020341217733646472982286222338860566076161977786095675944552232391481278782019346283900959677167026636830252067048759720251671811058647569724495547940966885025629807079171218371644528053562232396674283745310132242492367274184667845174514466834132589971388067076980563188513333661165819462428837210575342101036356974189393390097403614434491507672459254969638032776897417674577487775755539964915035731988499983726435005007850876000232292458554577437739427313453671492956668188219600633325930981748162455965093222648173134777571527681591366164711307355510889316052064146089646772869610726671696699221157985834325663661400034831442431209123478778078255846830522226390964119818784903330200488705212765569163495571851459355520398928214206285080883954881888668509262455490889283862560453598662919522224935145694435885396500780651530829377030371611921181207362217397805303962112100190783763061909945889717878397740711340114311597934724670601992737526668932871436226135393872881664511222789565256059138002651403875484920711316522536260604255269532161594824301047729082877262812899724246757871448545439896

d = pow(e,-1,p*(p-1))

msg = pow(ct,d,n)

long_to_bytes(msg)

#Output: b'crypto{squar3_r00t_i5_f4st3r_th4n_f4ct0r1ng!}'
```

### Flag
> crypto{squar3_r00t_i5_f4st3r_th4n_f4ct0r1ng!}

<!-- -----------------------------------------------Chall Manyprime--------------------------------------------------------------------------------------------------------------- -->
### 5) Manyprime
Using one prime factor was definitely a bad idea so I'll try using over 30 instead.
"If it's taking forever to factorise, read up on factorisation algorithms and make sure you're using one that's optimised for this scenario."
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving

Python Code As Follows:
```python
from Crypto.Util.number import long_to_bytes

n = 580642391898843192929563856870897799650883152718761762932292482252152591279871421569162037190419036435041797739880389529593674485555792234900969402019055601781662044515999210032698275981631376651117318677368742867687180140048715627160641771118040372573575479330830092989800730105573700557717146251860588802509310534792310748898504394966263819959963273509119791037525504422606634640173277598774814099540555569257179715908642917355365791447508751401889724095964924513196281345665480688029639999472649549163147599540142367575413885729653166517595719991872223011969856259344396899748662101941230745601719730556631637
e = 65537
ct = 320721490534624434149993723527322977960556510750628354856260732098109692581338409999983376131354918370047625150454728718467998870322344980985635149656977787964380651868131740312053755501594999166365821315043312308622388016666802478485476059625888033017198083472976011719998333985531756978678758897472845358167730221506573817798467100023754709109274265835201757369829744113233607359526441007577850111228850004361838028842815813724076511058179239339760639518034583306154826603816927757236549096339501503316601078891287408682099750164720032975016814187899399273719181407940397071512493967454225665490162619270814464

factorize = [ 9282105380008121879,9303850685953812323,9389357739583927789,10336650220878499841,10638241655447339831, 11282698189561966721,11328768673634243077,11403460639036243901,11473665579512371723,11492065299277279799,11530534813954192171,11665347949879312361,12132158321859677597,12834461276877415051,12955403765595949597,12973972336777979701,13099895578757581201,13572286589428162097,14100640260554622013,14178869592193599187,14278240802299816541,14523070016044624039,14963354250199553339,15364597561881860737,15669758663523555763,15824122791679574573,15998365463074268941,16656402470578844539,16898740504023346457,17138336856793050757,17174065872156629921,17281246625998849649]

tot = 1; 

for i in factorize:
    tot = tot*(i-1)
tot
Out[47]: 580642391898843191487404652150193463439642600155214610402815446275117822457602964108279991178253399797937961990567828910318944376020941874995912942457183778540787232677949141800666918857974957805860863128934894322453334083108951829885566055541321469492863749601696156719452204625091396670183612468234453545730714411260422415053794985900973204357184470104831581957188055965458235216412636167147716884241110058234315146752181551500634472836779298794303330378218517375396697137335380548442818167481491481087606998467945980408909917714107491743183639877866494931448463312524563384587536906823474872320000000000000000

d = pow(e,-1,tot)

msg = pow(ct,d,n)

long_to_bytes(msg)

# Output: b'crypto{700_m4ny_5m4ll_f4c70r5}'
```

### Flag
> crypto{700_m4ny_5m4ll_f4c70r5}



<!-- -----------------------------------------------Section Ends Here ------------------------------------------------------------------------------------------------------------------------ -->
## Public Exponent
<!-- -----------------------------------------------Chall Manyprime--------------------------------------------------------------------------------------------------------------- -->
### 1) Salty
Smallest exponent should be fastest, right?
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving

Python Code As Follows:
```python
from Crypto.Util.number import long_to_bytes

n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
e = 1
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485

tot = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873766

d = pow(e,-1,tot)

msg = pow(ct,d,n)

print(long_to_bytes(msg))
# Output: b'crypto{saltstack_fell_for_this!}'
```

### Flag
> crypto{saltstack_fell_for_this!}

### 2) Modulus Inutilis
My primes should be more than large enough now!
[Click here for the challenge](https://cryptohack.org/challenges/rsa/)

### Solving 
Python Code As Follows:
```python
from Crypto.Util.number import long_to_bytes
from gmpy2 import iroot

n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
e = 3
ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

print(long_to_bytes(int(iroot(ct, 3)[0])))

# Output:  b'crypto{N33d_m04R_p4dd1ng}'
```

### Flag 
> crypto{N33d_m04R_p4dd1ng}
